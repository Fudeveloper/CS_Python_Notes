# 数据库面试题


### 1.DNS: 域名解析系统。
是一个将域名和IP地址相互映射的分布式数据库。

解析过程（分级解析）：
根域名 -- 顶级域名 -- 二级域名

步骤（递归查询本地服务器，迭代查询其他远程服务器）：
- 看看DNS缓存里有没有，有的话直接返回；
- 使用UDP向DNS服务器发送查询消息；
- 接收返回的响应消息；

**传输协议：**  
除超过512字节和主从DNS服务器的区域传送外，都是用UDP协议。
- **为什么使用UDP**：因为快啊！只需要一个请求一个应答就够了，而TCP需要三次握手，请求与应答、四次挥手。如果多几次查询，每次都要握手挥手的时间开销太大了。并且DNS查询的数据都很小。
- **为什么区域传送使用TCP**：因为可靠啊！从主DNS服务器上复制内容需要可靠，并且同步的数据可能超过512字节。


### 2. 浏览器输入URL（域名）到返回页面的全过程：
	1. DNS域名解析，得到IP地址；
	2. 拿到解析的IP地址进行TCP连接；
	3. 向服务器发送HTTP请求；
	4. 服务器处理请求；
	5. 服务器返回响应结果；
	6. 关闭TCP连接；
	7. 解析HTML；
	8. 渲染页面。


### 3. TCP连接的三次握手，四次挥手。
**3次握手**：
- 双方都确认自己和对方的收发能力是正常的，需要的最少握手次数。用不着4次，3次就够了。
- 此外，若使用2次握手，当客户端的失效连接请求到达服务器，服务器会误打开连接，浪费资源。
- 若第三次握手失败，服务器会关闭连接，防止SYN洪泛攻击。

**为什么建立连接是三次握手，关闭连接确是四次挥手:**
- 建立连接时，服务器处于listen状态，当收到客户端的SYN请求时，会将响应的SYN、ACK放在同一个响应报文里发送给客户端。
- 关闭连接时，服务器收到客户端的FIN请求，表示客户端不再发送数据，但此时还可以接收数据。因此，服务器可以先响应ACK给客户端，表示收到了请求，然后将服务器端还没发送完的数据全部发送给客户端之后再发送FIN表示不再发送数据。服务器将ACK和FIN分开发送，导致多了一次数据传输。

**为什么客户端最后在TIME_WAIT还要等待2MSL（最大报文存活时间）：**
- 保证服务器收到客户端的最后一个ACK，若这个ACK丢失，服务器会重发一次FIN+ACK，这时客户端还没有关闭连接，就能收到重发的请求并给出响应。同时重启2MSL计时器。
- 客户端发送完最后一个ACK后，本连接持续时间内的所有报文段都会从网络中消失，新的连接中就不会收到已经关闭的旧连接中的报文。


### 4. TCP流量控制：
流量控制是为了调整发送方的发送速率，使得接收方来得及接收。
接收方的确认报文中有一个窗口字段，用来控制发送方的窗口大小，从而控制发送速率。


### 5. TCP拥塞控制：
拥塞控制是为了降低整个网络的拥塞程度。当网络出现拥塞时，分组丢失引发重传，继而加重拥塞程度，因此需要控制。发送方维护一个叫做拥塞窗口的状态变量cwnd，实际决定发送数据量的还是发送窗口。

- 慢启动 & 拥塞避免：
	- 发送最初执行慢启动，cwnd = 1，发送方只能发送一个报文段。发送方每次收到ACK后将cwnd加倍。
	- 为避免成倍增加的cwnd使得网络拥塞的可能增加，设置慢启动阈值ssthreash。当cwnd >= ssthresh的时候，进入拥塞避免，每次只能将cwnd的值加一。
	- 若出现超时，则将 ssthresh减半，cwnd=1，重新开始慢启动。
- 快速重传 & 快速恢复：
	- 在接受方，每次只确认收到的最后一个有序报文段；
	- 在发送方，若收到m2的3次重复ACK，则可以确认m3丢失，此时执行快速重传，即立即重传m3；同时，由于只是丢包而不是网络拥塞，执行快速恢复：ssthresh = cwnd / 2 ，cwnd = ssthresh


### 6. TCP与UDP区别：
	1. 连接：TCP面向连接（传输前需要在双方建立可靠连接）；UDP非面向连接（不需要在传输前建立连接），直接往对面发送就行了；
	2. TCP可靠交付，有序交付；UDP尽可能最大交付，不保证有序；
	3. TCP面向字节流（TCP把上层到达的数据看作字节流，太大会划分，太小可累积）；UDP面向报文(应用层交给UDP多大的报文他就直接转发这个报文)；
	4. TCP有流量控制和拥塞控制，UDP的吞吐量只受数据生成速率、收发性能、带宽等影响；
	5. TCP需要维护连接，需要的资源更多；
	6. TCP全双工点对点通信，UDP可以一对一、一对多、多对一、多对多通信。



### 7. TCP如何实现可靠交付：
	1. 序列号：只确认最后一个有序到达的数据包，保证有序；
	2. 校验和：每个数据包保持一个端到端的校验和，接收方收到之后检查数据在传输过程中有没有改变，若发生了改变则丢弃；
	3. 流量控制：保证接收方缓冲区足够接收数据，防止丢失；
	4. 拥塞控制：降低网络拥塞程度，防止数据包丢失；
	5. 停止等待：发送一个数据包之后暂停发送，等到接收到对方的确认后在发送下一个数据包；若接收方接收到重复数据包则丢弃，但仍需返回确认；
	6. 超时重传：若超时未接受到对方的确认，立即重传数据包。


### 8. 如何让UDP实现可靠传输：
RUDP、RTP、UDT



### 9. TCP/UDP使用场景：
TCP（质量高）：
- HTTP、HTTPS、FTP、邮件传输协议等需要可靠交付的协议；
	
UDP（速度快）：
- 音频、视频等对实时性要求较高的多媒体通信；
- 数据包传输量较少的协议：如DNS；
- 广播、多播通信


### 10. HTTP常见状态码
**1XX：信息状态码**

	• 100 Continue，到目前为止都很正常
	
**2XX：成功状态码**

	• 200 OK：成功处理请求
	• 204 No Content：成功处理请求，但响应报文的数据主体为空，一般用在客户端不需要服务器返回数据时；
	• 206 Partial Content：成功处理请求，但客户端进行了范围请求，响应报文只包含Content-Range范围内的数据。
	
**3XX：重定向**

	• 301 Moved Permanently：永久重定向，资源永久地移动到了另外一个URI，服务器一般会返回这个URI；
	• 302 Found：暂时重定向，其他同上；
	• 303 See Other：同302，但明确客户端需要用GET；
	• 304 Not Modified：客户端发送附带条件的请求时，不满足条件，返回时无响应主体；
	• 307 Temporary Redirect：同302，但明确客户端不使用GET。
	
**4XX：客户端错误**

	• 400 Bad Request：请求报文中有语法或参数错误，服务器无法理解导致无法处理；
	• 401 Unauthorized：需要认证或认证失败；
	• 403 Forbidden：对请求资源的访问被拒绝；
	• 404 Not Found： 服务器找不到对应资源。
	
**5XX：服务器错误**

	• 501 Internal Server Error：服务器出错；
	• 503 Service Unavailable：服务器忙或服务器正在维护，无法请求。



### 11. HTTP请求报文：
	• HTTP请求行：请求方法(GET\POST\HEAD)、URL、协议版本
	• HTTP请求头：user-agent、accept、host
	• 空行
	• 请求数据主体：POST传输表单等数据时使用



### 12. HTTP 2.0与HTTP 1.1的区别：
**HTTP 1.1新特性：**

	• 默认长连接
	• 支持流水线
	• 支持同时打开多个TCP连接
	• 支持虚拟主机
	• 增加状态码100
	• 支持分块传输编码
	• 新增缓存处理置零max-age
	
**HTTP 1.X缺点：实现简单但性能低**

	• 需要打开多个连接才能实现并发和缩短延迟；
	• 不压缩请求和响应首部，增加不必要的流量；
	• 不支持有效的资源优先级，导致底层TCP连接利用率不高。

**HTTP 2.0 与HTTP 1.X：**

	1. 服务器端推送：客户端在请求一个资源时，服务器会将相关资源一同返回，客户端不需要再次发送请求；比如客户端请求main.html时，服务器见script.js与style.css一同发送给客户端；
	2. 请求和响应首部压缩：HTTP 1.1首部含有大量信息，每次都要重复发送。HTTP 2.0的客户端和服务器共同维护一个出现过的首部字段表，避免重复传输。此外，2.0还会使用Huffman编码对首部字段进行压缩。
	3. 新的二进制形式：HTTP 1.X是基于文本的，文本形式多样，而二进制只有01组合，因此使用二进制形式更加健壮；
	4. 多路复用：即连接共享，每个request对应一个id，一个连接中可以有多个request，接收端再根据id将每个request归属到不同的请求中。


### 13. Cookie Session区别：
	1. session在服务器，cookie在客户端（浏览器）；
	2. session默认放置在服务器的一个文件里，但其实还可以放在数据库或内存中；
	3. session的实现依赖session_id，一般需要使用cookie来获取session_id，但也可以在URL中传递session_id;
	4. 用户验证这种场合一般使用session；
	5. 维持一个会话（广义session）的核心就是客户端的唯一标识：session_id。


### 14. WebSocket:
HTTP的缺陷：单向通信，当客户端想知道服务器的状态时需要轮询，轮询效率低；  

WebSocket：

	• 实现了服务器端推送，真正平等的双向通讯；
	• 没有同源限制，客户端可以与任意服务器通信；
	• 可以传输文本或二进制数据；
	• 数据格式轻量，性能开销小，通信高效。


### 15. POST与GET的区别：
**GET：**

	• ‘读取’一个资源。
	• 反复读取不应该有副作用，也即‘幂等‘的。
	• 因为是读取，就可以将请求的数据缓存，降低开销；
**POST：**

	• ‘提交’一些信息让服务器执行一定的操作；
	• 这往往会产生一些结果，也即‘不幂等’的。
	• 不幂等就表示不能随意执行多次，因此不能缓存，也不能保存书签。
	
- 数据：GET只能由输入或点击一个URL触发，要携带数据只能下载URL附带的questionstring里。
POST一般由提交表单触发，提交时将表单编码在HTTP请求body里。
- 安全性：不管GET还是POST，只要是携带在URL里的参数都是明文的，因此从攻击的角度来说一样的不安全。只不过GET携带的数据都在URL上，相较于请求体中的数据更容易泄漏。唯一的安全手段就是HTTPS。
- 长度：有个说法是GET有长度限制，其实这个URL的长度限制，并且不同浏览器的限制不太一样。
- TCP次数：GET请求体中的内容是空的，只需要一次连接，服务器就能取出请求头里的信息并返回相应资源。而优化的POST第一次发送请求头，服务器进行验证返回100 continue，这时候再发送数据，避免无法处理的请求也传输了数据浪费带宽。

