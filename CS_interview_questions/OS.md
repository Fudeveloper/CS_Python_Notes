# 操作系统面试题


### 1.进程与线程的区别：
- 资源：进程是资源分配的基本单位，但线程不拥有资源，线程能访问其所属进程的资源；
- 调度：线程是独立调度的基本单位，同一进程中线程的切换不会引起进程的切换，而不同进程间线程的切换会引起进程的切换；
- 系统开销：进程的新建和撤销时，系统需要为其分配和回收资源，如内存空间和I/O设备等，开销远大于线程的新建和撤销。进程的切换需要当前进程CPU环境的保护和新进程环境的设置，而线程的切换只需要保存和设置少量的寄存器内容，开销很小。因此，线程的系统开销远低于进程。
- 通信：线程可以直接读写进程数据进行通信，但进程需要IPC（进程间通信技术）进行通信(管道、消息队列、共享内存)。


### 2. 多进程与多线程：
多进程：

	• 进程是一个程序在给定数据集上的一次运行；
	• 多进程并发执行，共享物理内存、磁盘、IO、打印机等资源；

多线程：

	• 线程是一个基本的CPU执行单位，必须依靠进程存活。线程是一个执行上下文（execution context），是CPU运行的一串指令；
	• 多线程并发执行，共享地址空间、打开的文件等父进程的全部资源；
	• 主线程完成从进程创建到结束的全部操作，期间其他的线程被创建或退出

python多进程：

	• 实现：multiprocessing.Process（）
	• 进程间通信：Queue多进程安全队列，pipe管道通信。

python多线程：

	• 实现：threading.Thread（）
	• GIL（Global Interpreter Lock）全局解释器锁：GIL是python设计之初为了数据安全所加的，只有在官方的Cpython解释器里面才有。一个python进程只有一个GIL，只有获取了GIL的线程才被允许执行。每次释放GIL都会经历线程竞争和线程切换而耗费资源，因此多核CPU中python多线程反而更耗时。
	• 加互斥锁保证多线程安全，即解决竞争，保证数据一致性【python中一般使用RLock可重入锁】。

```python
import threading
import multiprocessing
import time

def print_time(counter, delay, name):
	print('start:', name)
	for _ in range(counter):
		time.sleep(delay)
		print('counting: ', name, time.ctime(time.time()))
	print('end:', name)


if __name__ == '__main__':
	t1 = threading.Thread(target = print_time, args = (3, 1, 'thread_1'))
	t2 = threading.Thread(target = print_time, args = (3, 1, 'thread_2'))
	# t1.start()
	# t2.start()

	p1 = multiprocessing.Process(target = print_time, args = (5, 1, 'process_1'))
	p2 = multiprocessing.Process(target = print_time, args = (3, 1, 'process_2'))
	# p1.start()
	# p2.start()
```

选择多进程还是多线程：
	• CPU密集型：偏重于计算，频繁使用CPU，适合多进程。如机器学习。
	• I/O密集型：经常输入输出，适合多线程。如爬虫。


### 3. 协程：
- 协程是微线程，在一个线程中执行，执行过程中可以随时中断，由用户控制（进程和线程本质上是系统运行）。执行效率高，减少了线程切换和锁开销。
- 协程失去了标准线程使用多核的能力。**多进程+协程**，既可以利用多核，又能利用协程的高效率。
- 实现：asyncio（异步IO，即不用等待其结束就能进行其他操作），在yield处暂停等待指令。

**协程相比线程的优势：协程执行效率高。**
- 协程由用户控制，不需要线程切换开销。与多线程相比，线程数量越多，协程的优势越明显；
- 协程不需要锁机制。线程中需要用锁保护数据，而协程不需要写变量保护，只需要判断状态就好了。


### 4. 进程、线程、协程堆栈区别：
- 进程：有独立的堆栈，不共享堆也不共享栈；由操作系统调度；
- 线程：有独立的栈，共享堆而不共享栈；由操作系统调度；
- 协程：有独立的栈，共享堆而不共享栈；由程序员自己调度。


### 5. 进程调度：
- 批处理系统（周转时间）：先来先服务（短作业等待时间过长），短作业优先（饿死），最短剩余时间优先（短作业优先的抢占式版本）。	
- 交互式系统（快速响应）：时间片轮转，优先级调度，多级反馈队列


### 6. 进程同步：
- 对临界资源进行访问的代码为临界区，临界区需要互斥访问。
- 同步与互斥：同步是进程因合作产生制约关系，需要按一定的顺序执行。互斥是不同进程不能同时访问临界资源。
- 信号量：PV操作，P是当信号量大于0时-1，若为零进入休眠；V操作是唤醒休眠的进程，即+1。
- 互斥量：当信号量只能取01时即为互斥量，0表示临界区加锁，1表示临界区解锁。


### 7. 死锁，举个例子，如何预防：
- 死锁：互斥、非抢占、拥有并等待、循环等待。

> 例子：哲学家问题。几个哲学家坐在圆桌上，每两个哲学家之间有一只筷子，一个哲学家只有同时拥有两只筷子才能开始进食。若每个哲学家拿起左边的筷子，那么所有人就陷入了等待右边筷子的死锁。【解决：按顺序给每支筷子设定优先级，每个哲学家首先拿起低优先级的筷子，这样，除了最后一位哲学家，所有人都会先拿起左边的筷子，因此打破了循环】

- 死锁预防：破坏四个必要条件。
- 死锁避免：
	- 安全状态：没有死锁发生时，即使所有进程突然请求最大资源需求数，也存在调度顺序可以使每个进程运行完毕。
	- 银行家算法：判断满足贷款需求是否会进入不安全状态，不安全就拒绝。


### 8. 虚拟地址和物理地址：
虚拟内存是为了将物理内存扩充为更大的逻辑内存。为了更方便地管理内存，操作系统将内存抽象成地址空间，每个程序有自己对应地地址空间。地址空间被分为很多块，一块被称为一页。虚拟地址空间的页映射到物理地址空间，不用连续映射也不用全部映射。当引用的页没有映射到物理内存时，引发缺页中断，将其调入再重新执行命令即可。这使得一个程序可以在不完全装入内存地情况下执行。

内存管理单元（MMU）维护页表，保存程序虚拟地址空间与物理地址空间的映射关系。

虚拟地址 = 页面号 + 偏移量。



### 9. 页面置换算法：（缺页率最低）
- 最优：被置换出的页面最长时间不会再使用；
- 最近最久未使用；
- 最近未使用：每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。	
- 先进先出；


### 10. 分段
分页的表在一维地址空间动态增长可能发生覆盖，分段会将每个表分开成不固定大小并且可以动态增长的独立地址空间。段页式先将表分段，再将段分页，既有分段系统的共享和保护，又有分页系统的虚拟内存。
